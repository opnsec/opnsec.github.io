{"id":317,"date":"2018-07-20T14:51:40","date_gmt":"2018-07-20T14:51:40","guid":{"rendered":"https:\/\/opnsec.com\/?p=317"},"modified":"2021-07-30T20:07:09","modified_gmt":"2021-07-30T20:07:09","slug":"into-the-borg-ssrf-inside-google-production-network","status":"publish","type":"post","link":"https:\/\/opnsec.com\/2018\/07\/into-the-borg-ssrf-inside-google-production-network\/","title":{"rendered":"Into the Borg &#8211; SSRF inside Google production network"},"content":{"rendered":"<h3><img loading=\"lazy\" class=\" wp-image-327 aligncenter\" src=\"http:\/\/opnsec.com\/wp-content\/uploads\/2018\/07\/borg2-1024x498.png\" alt=\"Borglet status monitor\" width=\"864\" height=\"420\" srcset=\"https:\/\/opnsec.com\/wp-content\/uploads\/2018\/07\/borg2-1024x498.png 1024w, https:\/\/opnsec.com\/wp-content\/uploads\/2018\/07\/borg2-300x146.png 300w, https:\/\/opnsec.com\/wp-content\/uploads\/2018\/07\/borg2-768x374.png 768w, https:\/\/opnsec.com\/wp-content\/uploads\/2018\/07\/borg2.png 1864w\" sizes=\"(max-width: 864px) 100vw, 864px\" \/><\/h3>\n<h3><\/h3>\n<h3>Intro &#8211; Testing Google Sites and Google Caja<\/h3>\n<p>In March 2018, I reported an XSS in <a href=\"https:\/\/developers.google.com\/caja\/\" target=\"_blank\" rel=\"noopener noreferrer\">Google Caja<\/a>, a tool to securely embed arbitrary html\/javascript in a webpage.<br \/>\nIn May 2018, after the XSS was fixed, I realised that Google Sites was using an unpatched version of Google Caja, so I looked if it was vulnerable to the XSS. However, the XSS wasn&#8217;t exploitable there.<\/p>\n<p>Google Caja parses html\/javascript and modifies it to remove any javascript sensitive content, such as iframe or object tags and javascript sensitive properties such as document.cookie. Caja mostly parses and sanitizes HTML tags on the client side. However, for remote javascript tag (&lt;script src=&#8221;xxx&#8221;&gt;), the remote resource was fetched, parsed and sanitized on the server-side.<br \/>\nI tried to host a javascript file on my server (https:\/\/[attacker].com\/script.js) and check if the Google Sites server would fall for the XSS when parsed server-side but the server replied that https:\/\/[attacker].com\/script.js was not accessible.<\/p>\n<p>After a few tests, I realised that the Google Sites Caja server would only fetch Google-owned resources like https:\/\/www.google.com or https:\/\/www.gstatic.com, but not any external resource like https:\/\/www.facebook.com.<br \/>\nThat&#8217;s a strange behavior because this functionality is meant to fetch external resources so it looks like a broken feature. More interestingly, it is hard to determine whether an arbitrary URL belongs to Google or not, given the breadth of Google services. Unless&#8230;<\/p>\n<p>&nbsp;<\/p>\n<h3>Finding an SSRF in Google<\/h3>\n<p>Whenever I find an endpoint that fetches arbitrary content server-side, I always test for SSRF. I did it a hundred times on Google services but never had any luck. Anyway the only explanation for the weird behavior of the Google Caja server was that the fetching was happening on the internal Google network and that is why it could only fetch Google-owned resources but not external resources. I already knew this was a bug, now the question was whether it was a security bug!<\/p>\n<p>It&#8217;s very easy to host and run arbitrary code on Google servers, use Google Cloud services! I created a <a href=\"https:\/\/cloud.google.com\/appengine\/\" target=\"_blank\" rel=\"noopener noreferrer\">Google App Engine<\/a> instance and hosted a javascript file. I then used the URL of this javascript file on Google Sites as a external script resource and updated the Google Sites page. The javascript was successfully fetched and parsed by Google Caja server. I then checked my Google App Engine instance logs to see from where the resource was fetched and it came from 10.x.x.201, a private network IP! This looked very promising.<\/p>\n<p>I used the private IP as the url for the Google Sites javascript external resource and waited for the moment of truth. The request took more than 30 seconds to complete and at that time I really thought the request was blocked and I almost closed the page since I never had any luck with SSRF on Google before. However, when Google Caja replied, I saw that the reply size wasn&#8217;t around 1 KB like for a typical error message but 1 MB instead! One million bytes of information coming from a 10.x.x.x IP from Google internal network, I can tell you I was excited at this point! \ud83d\ude42<br \/>\nI opened the file and indeed it was full of private information from Google! \\o\/<\/p>\n<p>&nbsp;<\/p>\n<h3>Google, from the inside<\/h3>\n<p>First I want to say that I didn&#8217;t scan Google&#8217;s internal network. I only made 3 requests in the network to confirm the vulnerability and immediately sent a report to Google VRP. It took 48 hours to Google to fix the issue (I reported it on a Saturday), so in the meantime I couldn&#8217;t help but test 2-3 more requests to try to pivot the SSRF vulnerability into unrestricted file access or RCE but without luck.<\/p>\n<p><img loading=\"lazy\" class=\"aligncenter wp-image-326 size-full\" src=\"http:\/\/opnsec.com\/wp-content\/uploads\/2018\/07\/borg-1.png\" alt=\"Architecture of Borg\" width=\"490\" height=\"431\" srcset=\"https:\/\/opnsec.com\/wp-content\/uploads\/2018\/07\/borg-1.png 490w, https:\/\/opnsec.com\/wp-content\/uploads\/2018\/07\/borg-1-300x264.png 300w\" sizes=\"(max-width: 490px) 100vw, 490px\" \/><\/p>\n<p>The first request was to http:\/\/10.x.x.201\/. It responded with a server status monitoring page of a &#8220;Borglet&#8221;. After a Google search, I could confirm that I was indeed inside <a href=\"https:\/\/storage.googleapis.com\/pub-tools-public-publication-data\/pdf\/43438.pdf\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Borg, Google&#8217;s internal large-scale cluster management system<\/strong><\/a>\u00a0(<a href=\"https:\/\/www.infoq.com\/news\/2015\/04\/google-borg\" target=\"_blank\" rel=\"noopener noreferrer\">here<\/a> is a overview of the architecture). Google have open sourced the <a href=\"https:\/\/kubernetes.io\/blog\/2015\/04\/borg-predecessor-to-kubernetes\/\" target=\"_blank\" rel=\"noopener noreferrer\">successor of Borg, Kubernetes<\/a> in 2014. It seems that while Kubernetes is getting more and more popular, Google is still relying on Borg for its internal production infrastructure, but I can tell you it&#8217;s not because of the design of Borg interfaces! (edit: this is intended as a joke\u00a0\ud83d\ude1b )<br \/>\nThe second request was to http:\/\/10.x.x.1\/ and it was also a monitoring page for another Borglet. The third request was http:\/\/10.x.x.1\/getstatus, a different status monitoring page of a Borglet with more details on the jobs like permissions, arguments.<\/p>\n<p>Each Borglet represents a machine, a server.<\/p>\n<p>On the hardware side, both servers were using Haswell&#8217;s CPU @2.30GHz with 72 cores, which corresponds to a set of 2 or 3 Xeon E5 v3. Both servers were using the CPUs at 77%. They had 250GB of RAM, which was used at 70%. They had 1 HDD each with 2TB and no SSD. The HDD were almost empty with only 15GB used, so the data is stored elsewhere.<\/p>\n<p>The processing jobs (alloc and tasks) are very diverse, I believe this optimizes ressource usage with some jobs using memory, others using CPU, network, some with high priority, etc&#8230; Some services seem very active : Video encoding, Gmail and Ads. That should not be surprising since video processing is very heavy, Gmail is one of the main Google services and Ads is, well, Google&#8217;s core business. \ud83d\ude09<br \/>\nI didn&#8217;t see Google Sites or Caja in the jobs list, so either the SSRF was going through a proxy or the Borglet on 10.x.x.201 was from a different network than the\u00a010.x.x.201 IP I saw in my Google App Engine instance logs.<\/p>\n<p>Regarding the architecture, we can find jobs related to almost all of the components of the <a href=\"http:\/\/malteschwarzkopf.de\/research\/assets\/google-stack.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">Google Stack<\/a>, in particular MapReduce, BitTable, Flume, GFS&#8230;<br \/>\nOn the technology side, Java seems to be heavily used. I didn&#8217;t see any mention of Python, C++, NodeJS or Go, but that doesn&#8217;t mean it wasn&#8217;t used so don&#8217;t draw conclusions. \ud83d\ude1b<br \/>\nI should mention that Borg, like Kubernetes, relies on containers like Docker, and VMs. For video processing, it seems they are using <a href=\"https:\/\/github.com\/google\/gvisor\" target=\"_blank\" rel=\"noopener noreferrer\">Gvisor<\/a>, a Google open-source tool that looks like a trade-off between containers performance and VMs security.<\/p>\n<p>Parameters gives some information on how to reach the applications through network ports. On Borg, it seems that all applications on a server share the same IP address and each has some dedicated ports.<\/p>\n<p>Apps arguments were the most fun part for me because it is almost code. I didn&#8217;t find Google Search secret algorithm but there was some cool queries like this:<pre><code >MSCR(M(Customer.AdGroupCriterion+Customer.AdGroupCriterion-marshal+FilterDurianAdGroupCriterion+FilterNeedReviewAdGroupCriterion+GroupAdGroupCriterionByAdGroupKey+JoinAdGroupData\/MakeUnionTable:3)+M(JoinAdGroupData\/MakeUnionTable:2)+M(Customer.AdGroup+Customer.AdGroup-marshal+FilterDurianAdGroup+ParDo(AdGroupDataStripFieldsFn)+JoinAdGroupData\/MakeUnionTable)+R(JoinAdGroupData\/GroupUnionTables+JoinAdGroupData\/ConstructJoinResults+JoinAdGroupData\/ExtractTuples+ExtractCreativeAndKeywordReviewables))<\/code><\/pre><\/p>\n<p>If you wonder what&#8217;s Gmail system user, it&#8217;s <pre><code >gmail@prod.google.com<\/code><\/pre>There is also a user &#8220;legal-discovery@prod.google.com&#8221; that has permission &#8220;auth.impersonation.impersonateNormalUser&#8221; on &#8220;mdb:all-person-users&#8221;. (edit: for clarification, I just saw these strings close to each other in a big array and assumed that&#8217;s what it meant)<\/p>\n<p>There was also a little bit of history which showed that most jobs where aborted before finishing.<\/p>\n<p>At last, there was a lot of url to other servers or applications endpoints. In particular, I tried to access a promising-looking http:\/\/wiki\/ url but it didn&#8217;t work. I tested a <pre><code >\/getFile?FileName=\/sys\/borglet\/borglet.INFO<\/code><\/pre> url but got an unauthorized response. I also tried to change the FileName parameter but got error messages.<\/p>\n<p>&nbsp;<\/p>\n<h3>Google VRP response<\/h3>\n<p>I reported the issue on Saturday May 12, 2018, and it was automatically triaged as a P3 (medium priority) issue. On Sunday I sent an email to Google Security that they might want someone to have a look at this. On Monday morning the issue was escalated to P0 (critical) then later decreased to P1. On Monday night the vulnerable endpoint was removed and the issue fixed.<\/p>\n<p>It&#8217;s not easy to determine the impact of an SSRF because it really depends on what&#8217;s in the internal network. Google tends to keep most of its infrastructure available internally and uses a lot of web endpoints, which means that in case of a SSRF, an attacker could potentially access hundreds if not thousands of internal web applications. On the other hand, Google heavily relies on authentication to access resources which limits the impact of a SSRF.<br \/>\nIn this case, the Borglet status monitoring page wasn&#8217;t authenticated, and it leaked a lot of information about the infrastructure. My understanding is that in Kubernetes, this page is authenticated.<\/p>\n<p>Google VRP rewarded me with $13,337, which corresponds to something like unrestricted file access! They explained that while most internal resources would require authentication, they have seen in the past dev or debug handlers giving access to more than just info leaks, so they decided to reward for the maximum potential impact. I&#8217;d like to thank them for the bounty and for their quick response.<\/p>\n<p>&nbsp;<\/p>\n<p>That&#8217;s it for this story, I hope you enjoyed it as much I did and feel free to comment!<\/p>\n\n<div class=\"twitter-share\"><a href=\"https:\/\/twitter.com\/intent\/tweet?via=opnsec\" class=\"twitter-share-button\">Tweet<\/a><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Intro &#8211; Testing Google Sites and Google Caja In March 2018, I reported an XSS in Google Caja, a tool to securely embed arbitrary html\/javascript in a webpage. In May 2018, after the XSS was fixed, I realised that Google Sites was using an unpatched version of Google Caja, so I looked if it was&hellip; <a class=\"read-more\" href=\"https:\/\/opnsec.com\/2018\/07\/into-the-borg-ssrf-inside-google-production-network\/\">Read More<\/a><\/p>\n","protected":false},"author":2,"featured_media":0,"comment_status":"closed","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"spay_email":""},"categories":[9],"tags":[11,10,13,12],"jetpack_featured_media_url":"","_links":{"self":[{"href":"https:\/\/opnsec.com\/wp-json\/wp\/v2\/posts\/317"}],"collection":[{"href":"https:\/\/opnsec.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/opnsec.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/opnsec.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/opnsec.com\/wp-json\/wp\/v2\/comments?post=317"}],"version-history":[{"count":33,"href":"https:\/\/opnsec.com\/wp-json\/wp\/v2\/posts\/317\/revisions"}],"predecessor-version":[{"id":379,"href":"https:\/\/opnsec.com\/wp-json\/wp\/v2\/posts\/317\/revisions\/379"}],"wp:attachment":[{"href":"https:\/\/opnsec.com\/wp-json\/wp\/v2\/media?parent=317"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/opnsec.com\/wp-json\/wp\/v2\/categories?post=317"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/opnsec.com\/wp-json\/wp\/v2\/tags?post=317"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}